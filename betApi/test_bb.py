# Generated by Selenium IDE
import time
import json
import random
import logging
import pathlib
from datetime import datetime, timedelta
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support import expected_conditions
from selenium.webdriver.support.wait import WebDriverWait
from selenium.common.exceptions import TimeoutException
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.desired_capabilities import DesiredCapabilities
from bs4 import BeautifulSoup


class TestBb():
    def __init__(self) -> None:
        # Initialize Logging file
        # Define a format for your log messages
        current_directory = pathlib.Path(__file__).parent.absolute()
        logFileDir = f"{current_directory}/BB.log"
        logging.basicConfig(filename=logFileDir, level=logging.DEBUG)
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s')

        # Create a file handler and set the formatter
        file_handler = logging.FileHandler(logFileDir)
        file_handler.setFormatter(formatter)

        # Add the file handler to the root logger
        logging.root.addHandler(file_handler)
        # Create a logger with a specific name
        self.logger = logging.getLogger(logFileDir)
        self.user_agents = [
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3",
            "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3",
            'Windows 10/ Edge browser: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.135 Safari/537.36 Edge/12.246',
            'Windows 7/ Chrome browser: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.111 Safari/537.36',
            'Mac OS X10/Safari browser: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_2) AppleWebKit/601.3.9 (KHTML, like Gecko) Version/9.0.2 Safari/601.3.9',
            'Linux PC/Firefox browser: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:15.0) Gecko/20100101 Firefox/15.0.1',
            'Chrome OS/Chrome browser: Mozilla/5.0 (X11; CrOS x86_64 8172.45.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.64 Safari/537.36'
            # Add more user agents as needed
        ]  # List of user agents you want to use
        self.logger.info('Initailizing class')
        self.setup_method(self)
        self.test_bb()

    def setup_method(self, method):
        """Start up the program"""
        self.logger.info('Setting up process')
        chrome_options = Options()

        # Set a random user agent before each request
        chrome_options.add_argument(
            f"user-agent={random.choice(self.user_agents)}")

        # Create a Chrome WebDriver with the specified options
        self.driver = webdriver.Chrome(options=chrome_options, keep_alive=True)
        self.vars = {}
        self.logger.info('Setting up process done')

    def teardown_method(self, method):
        """Tear down the connection"""
        # Clear cookies to simulate clearing browser history
        self.logger.info('Ending process')
        self.logger.info("Starting deleting all data")
        self.driver.delete_all_cookies()
        self.logger.info("Finished deleting all data")
        self.driver.quit()

    def wait_for_element_present(self, by, value, timeout=10):
        """Waiting for an element to load befor carrying on"""

        self.logger.info("Waiting for a particular elemnt")
        WebDriverWait(self.driver, timeout).until(
            EC.presence_of_element_located((by, value))
        )

    def save_html(self, filename='saved_page.html'):
        """Save the html  file for later parsing"""

        self.logger.info("Saving html")
        with open(filename, 'w', encoding='utf-8') as file:
            file.write(self.driver.page_source)

    def read_saved_html(self, filename='saved_page.html'):
        """Read saved html"""

        self.logger.info("Reading data")
        with open(filename, 'r', encoding='utf-8') as file:
            return file.read()

    def parse_data(self):
        # Example: Read the saved HTML and print it
        saved_html = self.read_saved_html()

        self.logger.info("Starting Parsing html")
        soup = BeautifulSoup(saved_html, 'lxml')
        datas = (soup.find_all('tbody'))
        parsed_data = {}
        all_parsed_data = []

        self.logger.info("Starting Extracting all data")
        for i in datas:

            percentage = i.find('div', class_='percent').text
            lifetime = i.find('div', class_='lifetime').text
            sportName = i.select_one('.sport .percent').text
            startTime = i.select_one('.sport .lifetime span').text
            bookies_data = {}

            for index, row in enumerate(i.find_all('tr', class_='odd_row'), start=1):
                bookie_data = {
                    'bookmaker': row.select_one('.bookmaker_td').text.strip(),
                    'team_league': row.select_one('.team_league_td .liga').text.strip(),
                    'odds_types': row.select_one('.odds_types').text.strip(),
                    'value': row.select_one('.values').text.strip()
                }
                bookies_data[index] = bookie_data

            parsed_data = {
                "profit": {
                    "percentage": percentage,
                    "lifetime": lifetime
                },
                "sport": {
                    "sportName": sportName,
                    "startTime": startTime
                },
                "bookMakers": bookies_data
            }
            all_parsed_data.append(parsed_data)
            self.logger.info("Finished Extracting all data")
        return all_parsed_data

    def write_to_json(self, data, filename):
        """save to a json file"""
        self.logger.info("Writing data to json file")
        # Convert generator to a list of dictionaries
        with open(filename, 'w', encoding='utf-8') as json_file:
            json.dump(data, json_file, indent=2)
        # You can perform additional analysis on the saved HTML here

    def refresh_browser_every_minute(self, timing: int = 60):
        """Refresh every given time"""
        self.logger.info("Refresh for new data")
        while True:
            # Put the code for the specific element you want to wait for here
            # For example, waiting for the element with ID "user_email"
            self.wait_for_element_present(By.CLASS_NAME, "percent")

            # Your other test steps go here
            # Save the HTML content after each refresh, overwriting the previous file
            self.save_html()

            # Extract the file
            # Call the write_to_json function with the generate_data generator function
            self.write_to_json(self.parse_data(), 'data.json')

            # Refresh the browser
            self.driver.refresh()

            # Wait for one minute before the next iteration
            self.logger.info("Refresh for new data done")
            time.sleep(timing)

    def test_bb(self):
        try:
            """Performing all the site checking functions"""
            # Test name: bb
            # Step # | name | target | value
            # 1 | open | /en/users/sign_in |
            self.driver.get("https://breaking-bet.com/en/users/sign_in")
            # 2 | setWindowSize | 1050x880 |
            self.driver.set_window_size(1050, 880)
            # 3 | click | id=user_email |
            self.driver.find_element(By.ID, "user_email").click()
            # 4 | type | id=user_email | chibuzoi410@gmail.com
            self.driver.find_element(By.ID, "user_email").send_keys(
                "chibuzoi410@gmail.com")
            # 5 | type | id=user_password | EML9i@9B5nCx4EX
            self.driver.find_element(
                By.ID, "user_password").send_keys("EML9i@9B5nCx4EX")
            # 6 | click | id=user_remember_me |
            self.driver.find_element(By.ID, "user_remember_me").click()
            # 7 | click | name=commit |
            self.driver.find_element(By.NAME, "commit").click()
            # 8 | refresh every 1min
            self.refresh_browser_every_minute()
        except TimeoutException as te:
            self.logger.critical(f"End on Time out:- {te}")
            self.teardown_method(self)
            time.sleep(30)
            self.__init__()
        except ValueError as ve:
            # Handle the specific exception
            self.logger.error(f"Caught a ValueError: {ve}")
            self.teardown_method(self)
        except TypeError as te:
            # Handle a different specific exception
            self.logger.error(f"Caught a TypeError: {te}")
            self.teardown_method(self)
        except Exception as e:
            # Handle any other exception
            self.logger.error(f"An unexpected error occurred: {e}")
            self.teardown_method(self)
        else:
            # Code to be executed if no exception occurred
            self.logger.info("No exception occurred.")
        finally:
            # Code to be executed whether an exception occurred or not
            self.logger.info("This will be executed no matter what.")


TestBb()
